#python3 script to walk directory and strip first or last bytes from each file under that directory
#It also adds 'AMENDED' to the front of the file name so you know what is new
#This does not look at file headers. It is not smart. 
#
#   Tool workflow
#  1. ID a target folder containing files that need bytes removed
#   |
#  2. Choose an output folder to store changed files
#   |
#  3. Select # of bytes to remove from start OR end of files
#   |
#   <OPTIONAL>
#   |
#  4. Preview window to see raw binary of a sample file


#   TO DO 
#   X   Functioning GUI 
#   /   Preview window to show user the expected outcome of their data on hex view of a sample file. Use color or strikethru?
#   X   Progress bar
#       Activity report - txt format include time/date, user settings, files processed. This will be text?
#       Should there be logic to check for known file signatures? Probably not unless this thing becomes a carver.

import os
import PySimpleGUI as sg
import itertools

ASCII_character_start = 33       #ASCII characters to interpret
ASCII_character_end = 126

#********************* FUNCTIONS ***********************

def progress_bar():
    direct = '//Users//nlc//Desktop//testforCIO'
    master_file_list = os.listdir(direct)


def auto_preview():     #this function walks the source directory and finds the smallest file that is over 512 bytes for binary preview

    direct = values["SOURCE"]       
    n = 1
    all_files = os.listdir(direct)
    sort_files_by_size = sorted(all_files, key=lambda fileName: os.path.getsize(os.path.join(direct, fileName)))  #creates a list of files in directory by size
    get_smallest = sort_files_by_size[:n]               # Selects the smallest file
    get_smallest = get_smallest[0]                      # Takes the list result and chooses the only entry to get a string result
    get_smallest = os.path.join(direct, get_smallest)   # creates an absolute path description of smallest file
    if os.path.getsize(get_smallest) >= 512:            # only allows files larger than 512 bytes to prevent filesystem metadata artifacts from being brought in
        global Auto_preview_file
        Auto_preview_file = get_smallest
        return(Auto_preview_file)
    else:
        window['-ML1-'+sg.WRITE_ONLY_KEY].print("Auto-preview not available. Select a file for preview.")  # Error msg
    

def hex_group_formatter(iterable):
    chunks = [iter(iterable)] * 8              #iter * 8byte groupings
    return '   '.join(
        ' '.join(format(x, '0>2x') for x in chunk)
        for chunk in itertools.zip_longest(*chunks, fillvalue=0))

def ascii_group_formatter(iterable):                        # formats the ascii interpreter
    return ''.join(
        chr(x) if ASCII_character_start <= x <= ASCII_character_end else '.'
        for x in iterable)

def hex_viewer(filename, chunk_size=16):                #This reads 16 bytes at a time and creates a formatted line of the Address - hex valuues - ASCII interpretation on each line
    header = hex_group_formatter(range(chunk_size))     #This approach may not be ideal. How the hell am I going to update hex value colors this way?!?  Will have more coffee and rethink.
    yield 'ADDRESS     {:<53}      ASCII'.format(header)
    yield ''
    template = '{:0>8x}    {:<53}{}'

    with open(filename, 'rb') as stream:                # Opens file to be read in binary
        for chunk_count in itertools.count(1):
            chunk = stream.read(chunk_size)
            if not chunk:
                return
            yield template.format(
                chunk_count * chunk_size,
                hex_group_formatter(chunk),
                ascii_group_formatter(chunk))

def Cut_What_Where():                                                       #    Function to remove selected binary values from file
    BYTES_TO_REMOVE_FROM_START = values["STARTBYTES"]                       #   Gui input for bytes to remove from start
    if BYTES_TO_REMOVE_FROM_START != "":                                    #   Checks that something is entered for bytes
        try:
            BYTES_TO_REMOVE_FROM_START = int(BYTES_TO_REMOVE_FROM_START)        #   Getting the Byte input for starting bytes and converting from str to integer
        except(ValueError):
            print("Error - Byte count must be a decimal numeric value")
    
    BYTES_TO_REMOVE_FROM_END = values["ENDBYTES"]                           #   Getting the GUI Byte input for ending bytes and converting from str to integer
    if BYTES_TO_REMOVE_FROM_END != "":                                      #   Checks that something is entered for bytes
        try:
            BYTES_TO_REMOVE_FROM_END = int(BYTES_TO_REMOVE_FROM_END)
        except(ValueError):
            print("ValueError - Byte count must be a decimal numeric value")
            
    input_directory = values['SOURCE']  
    output_directory = values['OUT']                                        
    byte_NUM_start = values["STARTOFFILE"]
    byte_NUM_end = values['ENDOFFILE']
    file_count = sum(len(files) for _, _, files in os.walk(input_directory))  #gets a recursive count of all files in input directory.  The "_" in the sum function are just skipped variables for root and dir
    go_up = 0                        #   This value is a baseline, see below that it increments by +1 for each loop that happens below. Need this for progress bar. 
 

    if isinstance(BYTES_TO_REMOVE_FROM_START, int) and byte_NUM_start == True:  # check - Did the user input an integer
        pass
    elif isinstance(BYTES_TO_REMOVE_FROM_END, int) and byte_NUM_end  == True:   # check - Did the user input an integer
        pass
    else:
        return sg.Popup("TypeError - Byte count must be a decimal numeric value")  #popup window showing error that interupts the process
        
    try:    
        for root, dirs, files in os.walk(input_directory):                      #walks directory, subdirectories, and files
            for file in files:                                                  #iterates to address each found file
                go_up = go_up + 1
                sg.OneLineProgressMeter('progress', go_up, file_count, orientation="H")     #   progress bar
                filepath = os.path.join(root,file)                              #creates an absolute path for each found file
                out_name = os.path.join(output_directory, "AMENDED_" + file)    #creates a new name for altered files
                
                with open(filepath, 'rb') as in_file:                           #reads binary data of original file
                    with open(out_name, 'wb') as out_file:                      #makes a new output file
                        try:
                            if byte_NUM_start == True:
                                out_file.write(in_file.read()[BYTES_TO_REMOVE_FROM_START:])     #writes binary data less first N bytes from original file to new file
                            elif byte_NUM_end == True:
                                out_file.write(in_file.read()[:-BYTES_TO_REMOVE_FROM_END])       #writes binary data less last N bytes from original file to new file
                        except(TypeError):
                            sg.Popup("TypeError - Byte count must be a decimal numeric value")  #popup window showing error
    except(FileNotFoundError):
        sg.Popup("Check that you selected a valid input and output folder")   #popup for error.  
        print('test')
    except(TypeError):
        sg.Popup("TypeError - Byte count must be a decimal numeric value")  #popup window showing error
        window.refresh()
    # print(file_count)   # for testing   


#***************************** GUI STUFF *********************************************


sg.theme('lightgray6')  #GUI color scheme

preview_tab = [[sg.Button('Preview Byte Selection', key="PREVIEW"), sg.Text(" "*60)],               # Preview Tab Window
        [sg.Radio('Automactically Select Preview File from Input Directory', font=('Arial', 12), group_id=3, default=True, key="AUTO")],
        [sg.Radio("Manually Select Preview File", font=('Arial', 12), group_id=3, key="ChooseFile")],  
        [sg.Text('Select a sample file to preview the results before execution:', font=('Arial', 12))],
        [sg.Input(key='PREVIEWFILE',), sg.FileBrowse(key='PREVIEWFILE')],
        [sg.Text('')],
        [sg.MLine(key='-ML1-'+sg.WRITE_ONLY_KEY,font='courier',size=(82,14))]]      # Console window in GUI

Gouger_tab = [[sg.Text('')],                                                                        #Cutting Tab Window
        [sg.Text('     '), sg.Text('Select Input and Output Directory:', font=('Arial', 12))],
        [sg.Text('     '),sg.Input("Folder Containing Source Data", font=('Arial', 12), key='SOURCE',), sg.FolderBrowse(key='SOURCE'), sg.Text(' '*10)], 
        [sg.Text('')],
        [sg.Text('     '),sg.Input("Output Folder", font=('Arial', 12), key='OUT',), sg.FolderBrowse(key='OUT')],
        [sg.Text('     '),sg.Text('')],
        [sg.Text('     '),sg.Radio('# of Bytes to Remove from Start of Files (Dec)', key="STARTOFFILE", font=('Arial', 12), default=True, group_id=1.), sg.Input('', size=(10,2), key="STARTBYTES")],
        #[sg.Text('_'*82)],
        [sg.Text('     '),sg.Radio('# of Bytes to Remove from End of Files (Dec) ', enable_events=True ,key="ENDOFFILE", font=('Arial', 12), group_id=1), sg.Input('', size=(10,2), key="ENDBYTES")],
        [sg.Text('     '),sg.Checkbox('Include Activity Log', font=('Arial', 12))],        
        [sg.Text('')],
        [sg.Text('     '),sg.Button('REMOVE PADDED DATA FROM SELECTED FILES', key='Ok')]]

layout = [[sg.Text('LOP', font=('Impact', 40, 'bold italic'))], 
        [sg.Text('A Tool to Remove Padded Data from the Start or End of Bulk Files.', font=('Arial', 12,'bold'))],                                # Main Window
        [sg.TabGroup([[sg.Tab('Cutting', Gouger_tab, font=('Arial', 12)), sg.Tab("Previewing", preview_tab)]])]]
        

#******************** BRINGS GUI & FUNCTIONS TOGETHER ********************************


# Create the Window
window = sg.Window('North Loop Consulting', layout, no_titlebar=False, alpha_channel=1, grab_anywhere=False)

# Event Loop to process "events" and get the "values" of the inputs
while True:
    event, values = window.read()
    if event == sg.WIN_CLOSED or event == 'Exit': # if user closes window or clicks cancel
        break
    if event == 'Ok':
        Cut_What_Where()
    if event == 'PREVIEW':
        try:
            if values["AUTO"] == True:
                try:
                    auto_preview()      #function to find a file for binary preview
                except(FileNotFoundError):
                    window['-ML1-'+sg.WRITE_ONLY_KEY].print("*****  You must choose a source directory  *****\n")
                prefile = Auto_preview_file
                for line in hex_viewer(prefile):
                    window['-ML1-'+sg.WRITE_ONLY_KEY].print(line)
            
            elif values["ChooseFile"] == True:  #Checkbox for manual preview file selection
                try:
                    prefile = values["PREVIEWFILE"]
                    if len(prefile) <= 5:           #checks length of file path to prevent empty entries
                        window['-ML1-'+sg.WRITE_ONLY_KEY].print("*****  You must select a preview file  *****\n")   # In-console error msg
                        
                    if len(prefile) > 5:            #checks length of file path to allow entries with actual path
                        for line in hex_viewer(prefile):
                            window['-ML1-'+sg.WRITE_ONLY_KEY].print(line)
                            window.refresh()
                except:
                    window['-ML1-'+sg.WRITE_ONLY_KEY].print("*****  You must select a preview file  *****\n")  # In-console error msg
        except:
            window.refresh()
    window.refresh()
window.close()
            
